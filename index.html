<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sintetizador Espectro-Colorido</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>üé® Desenhe Seu Som!</h1>

    <div class="controls-container">
        <label for="colorPicker">Cor:</label>
        <input type="color" id="colorPicker" value="#ff0000">
        
        <label for="brushSize">Tamanho do Pincel:</label>
        <input type="range" id="brushSize" min="1" max="50" value="10">
        <span id="brushSizeValue">10</span>px
        
        <button onclick="sendDrawingData()" id="playButton">‚ñ∂Ô∏è Tocar Desenho</button>
        <button onclick="clearCanvas()" id="clearButton">üóëÔ∏è Limpar Tela</button>
    </div>

    <canvas id="drawingCanvas" width="800" height="400"></canvas>

    <audio id="audioPlayer" controls></audio>
    
    <script>
        // --- Vari√°veis Globais ---
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');
        const audioPlayer = document.getElementById('audioPlayer');
        const playButton = document.getElementById('playButton');
        
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        // Inicializa√ß√£o
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height); // Define fundo branco

        // Adiciona funcionalidade de Limpar Tela
        function clearCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            audioPlayer.src = ''; // Limpa o √°udio do player
        }

        // Atualiza o valor do pincel
        brushSizeInput.addEventListener('input', () => {
            brushSizeValueSpan.textContent = brushSizeInput.value;
        });

        // --- Fun√ß√µes de Desenho ---
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            // Calcula a posi√ß√£o do mouse no canvas, escalando se a exibi√ß√£o for diferente do tamanho real do canvas (800x400)
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            return { x, y };
        }

        function startDrawing(e) {
            isDrawing = true;
            const { x, y } = getMousePos(e);
            
            // Inicia o caminho e move para a posi√ß√£o inicial
            ctx.beginPath(); 
            ctx.moveTo(x, y); 
            
            lastX = x;
            lastY = y;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function draw(e) {
            if (!isDrawing) return;

            const { x, y } = getMousePos(e);

            // 1. Configura√ß√µes do Pincel
            ctx.lineWidth = brushSizeInput.value;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round'; // Melhora a apar√™ncia das curvas
            ctx.strokeStyle = colorPicker.value;

            // 2. Tra√ßa a linha
            ctx.lineTo(x, y); // Desenha uma linha do ponto anterior (lastX, lastY) at√© o ponto atual (x, y)
            ctx.stroke();      // Exibe a linha
            
            // 3. Atualiza a posi√ß√£o para o pr√≥ximo segmento
            ctx.beginPath();
            ctx.moveTo(x, y);
            lastX = x; // Isto n√£o √© estritamente necess√°rio se usarmos moveTo(x, y) acima, mas ajuda a rastrear.
            lastY = y;
        }

        // Event Listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('mousemove', draw);

        // --- Fun√ß√µes de Convers√£o e Envio de Dados (SEM ALTERA√á√ÉO) ---
        
        /**
         * Converte RGB (0-255) para HSV (Matiz: 0-360, Satura√ß√£o/Valor: 0-1)
         */
        function rgbToHsv(r, g, b) {
            // ... C√≥digo inalterado ...
            r /= 255; g /= 255; b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const v = max; 
            
            const diff = max - min;
            const s = max === 0 ? 0 : diff / max; 

            let h; 
            if (diff === 0) {
                h = 0; 
            } else if (max === r) {
                h = (g - b) / diff + (g < b ? 6 : 0);
            } else if (max === g) {
                h = (b - r) / diff + 2;
            } else {
                h = (r - g) / diff + 4;
            }
            h /= 6;
            
            return [Math.round(h * 360), s, v]; 
        }


        /**
         * Coleta os dados de cor (HSV) de cada coluna vertical (pixel x) no canvas.
         */
        function getDrawingData() {
            // ... C√≥digo inalterado ...
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.getImageData(0, 0, width, height).data;
            const drawingData = []; 

            for (let x = 0; x < width; x++) {
                let rSum = 0, gSum = 0, bSum = 0;
                let pixelCount = 0;

                for (let y = 0; y < height; y++) {
                    const index = (y * width + x) * 4; 

                    // Se a cor for muito pr√≥xima do branco (Fundo), ignoramos 
                    if (imageData[index] < 250 || imageData[index + 1] < 250 || imageData[index + 2] < 250) {
                         rSum += imageData[index];
                         gSum += imageData[index + 1];
                         bSum += imageData[index + 2];
                         pixelCount++;
                    }
                }
                
                if (pixelCount > 0) {
                    const rAvg = Math.round(rSum / pixelCount);
                    const gAvg = Math.round(gSum / pixelCount);
                    const bAvg = Math.round(bSum / pixelCount);
                    
                    drawingData.push(rgbToHsv(rAvg, gAvg, bAvg));
                } else {
                    drawingData.push([0, 0, 0]); 
                }
            }
            return drawingData;
        }


        /**
         * Envia os dados de cor para o servidor Python
         */
        async function sendDrawingData() {
            // ... C√≥digo inalterado ...
            playButton.disabled = true;
            playButton.textContent = 'üé∂ Gerando √Åudio...';
            
            const dataToSend = getDrawingData();
            
            try {
                const response = await fetch('/generate-sound', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ drawing_data: dataToSend })
                });

                if (response.ok) {
                    audioPlayer.src = '/audio/output.wav?' + new Date().getTime(); 
                    audioPlayer.play();
                } else {
                    alert('Erro ao gerar som: ' + response.statusText);
                }
                
            } catch (error) {
                console.error('Erro de rede ou servidor:', error);
                alert('Erro ao conectar com o servidor Python. Certifique-se de que app.py est√° rodando.');
            } finally {
                playButton.disabled = false;
                playButton.textContent = '‚ñ∂Ô∏è Tocar Desenho';
            }
        }
    </script>
</body>
</html>